Deadlock is a situation in computing where two or more processes are unable to proceed because each is waiting for the other to release resources.

Consider an example when two trains are coming toward each other on the same track and there is only one track, none of the trains can move once they are in front of each other. This is a practical example of deadlock.


### How Does Deadlock occur in the Operating System?

Before going into detail about how deadlock occurs in the Operating System, let’s first discuss how the Operating System uses the resources present. A process in an operating system uses resources in the following way. 

- Requests a resource 
- Use the resource 
- Releases the resource 

A situation occurs in operating systems when there are two or more processes that hold some resources and wait for resources held by other(s). For example, in the below diagram, Process 1 is holding Resource 1 and waiting for resource 2 which is acquired by process 2, and process 2 is waiting for resource 1.

![[deadlock.png]]




### Necessary Conditions for Deadlock in OS

Deadlock can arise if the following four conditions hold simultaneously (Necessary Conditions) 

- **Mutual Exclusion:** Two or more resources are non-shareable (Only one process can use at a time).
- **Hold and Wait:** A process is holding at least one resource and waiting for resources. 
- **No Preemption:** Resources cannot be forcibly taken away from a process unless the process releases the resource. 
- **Circular Wait:** A set of processes waiting for each other in circular form.


###  Examples of Deadlock

There are several examples of deadlock. Some of them are mentioned below.

1. The system has 2 tape drives. P0 and P1 each hold one tape drive and each needs another one.

2. Semaphores A and B, initialized to 1, P0, and P1 are in deadlock as follows:
- P0 executes wait(A) and preempts.
- P1 executes wait(B).
- Now P0 and P1 enter in deadlock.

| P0       | P1      |
| -------- | ------- |
| wait(A); | wait(B) |
| wait(B); | wait(A) |

3. Assume the space is available for allocation of 200K bytes, and the following sequence of events occurs.

| P0            | P1            |
| ------------- | ------------- |
| Request 80KB; | Request 70KB; |
| Request 60KB; | Request 80KB; |

Deadlock occurs if both processes progress to their second request.


### What are the Methods For Handling Deadlock?

There are three ways to handle deadlock

- Deadlock Ignorance
- Deadlock Prevention
- Deadlock Avoidance
- Deadlock Detection and Recovery

#### 1. Deadlock Ignorance
In this approach, the **Operating system assumes that deadlock never occurs**. **It simply ignores deadlock**. This approach is **best suitable for a single end user system** where User uses the system only for browsing and all other normal stuff.

**There is always a tradeoff between Correctness and performance**. The operating systems like Windows and Linux mainly focus upon performance. However, the **performance of the system decreases if it uses deadlock handling mechanism all the time if deadlock happens 1 out of 100 times then it is completely unnecessary to use the deadlock handling mechanism all the time**.

In these types of systems, **the user has to simply restart the computer in the case of deadlock**. **Windows and Linux are mainly using this approach**.


#### 2. Deadlock Prevention
If we simulate deadlock with a table which is standing on its four legs then we can also simulate four legs with the four conditions which when occurs simultaneously, cause the deadlock.
However, if we break one of the legs of the table then the table will fall definitely. The same happens with deadlock, if we can be able to violate one of the four necessary conditions and don't let them occur together then we can prevent the deadlock.

###### 1. Mutual Exclusion
For some resources, like printers, mutual exclusion is necessary, and you cannot prevent it. However, for some other resources, you can modify the resource so it can be shared among processes. For example, files can be opened in read-only mode by multiple processes simultaneously.

###### 2. Hold and Wait
- **Request All Resources at Once:** One way to prevent hold and wait is to require a process to request all the resources it needs at once, before it begins execution. If all the resources are available, the process is granted them, and it proceeds. If not, the process waits until it can acquire all resources simultaneously.
  However, this sounds very practical but can't be done in the computer system because a process can't determine necessary resources initially. Process is the set of instructions which are executed by the CPU. Each of the instruction may demand multiple resources at the multiple times. The need cannot be fixed by the OS.
- **No Resource Holding:** Another method is to ensure that a process holding some resources is not allowed to request more. It must release all the resources it holds before requesting any new ones. However, this may lead to inefficient resource utilization and increased overhead due to repeated requests and releases.

###### 3. No Preemption
Deadlock arises due to the fact that a process can't be stopped once it starts. However, if we take the resource away from the process which is causing deadlock then we can prevent deadlock.

This is not a good approach at all since if we take a resource away which is being used by the process then all the work which it has done till now can become inconsistent.

Consider a printer is being used by any process. If we take the printer away from that process and assign it to some other process then all the data which has been printed can become inconsistent and ineffective and also the fact that the process can't start printing again from where it has left which causes performance inefficiency.

###### 2. Circular Wait
The **simplest and most effective method** to prevent circular wait is to impose an ordering of all resource types and require that each process requests resources in an increasing order of enumeration. For example, if a process needs resources R1, R2, and R3, it must request them in the order R1, R2, R3. This prevents circular chains of processes waiting for each other.
[[Explanation of How prevention of Circular Wait can prevent Deadlock | Explanation]]

###### Comparison
Among all the methods, violating Circular wait is the only approach that can be implemented practically.

| Condition        | Approach                               | Is it practically possible? |
| ---------------- | -------------------------------------- | --------------------------- |
| Mutual Exclusion | Spooling                               | NO                          |
| Hold and Wait    | Requesting all the resourses initially | NO                          |
| No Preemtion     | Snatch all resourses                   | NO                          |
| Circular Wait    | Order resources numerically            | YES                         |



