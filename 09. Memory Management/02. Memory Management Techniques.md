 ****
## 1. Contiguous Memory Management Technique
Contiguous memory management is a memory allocation technique where each process is allocated a single continuous block of memory based on the process's size. This means that a process's entire memory needs are placed in one uninterrupted section of physical memory.

**Contiguous Memory Management has two types:**
- Fixed(or Static) Partition
- Variable(or Dynamic) Partitioning

#### 1.1 Fixed Partition (Static Partition)
Fixed partitioning is a memory management technique where the main memory is divided into fixed-sized partitions or blocks (They all may be of same size or different). Each partition can hold exactly one process. The size of the partitions is determined at the time of system initialization and remains constant throughout the system's operation. When a process is loaded into memory, it is placed in one of the partitions that is large enough to accommodate it.

###### There are various cons of using this technique.

**1. Internal Fragmentation**
If the size of the process is lesser then the total size of the partition then some size of the partition get wasted and remain unused. This is wastage of the memory and called internal fragmentation.
As shown in the image below, the 4 MB partition is used to load only 3 MB process and the remaining 1 MB got wasted.

**2. External Fragmentation**
The total unused space of various partitions cannot be used to load the processes even though there is space available but not in the contiguous form.
As shown in the image below, the remaining 1 MB space of each partition cannot be used as a unit to store a 4 MB process. Despite of the fact that the sufficient space is available to load the process, process will not be loaded.

**3. Limitation on the size of the process**
If the process size is larger than the size of maximum sized partition then that process cannot be loaded into the memory. Therefore, a limitation can be imposed on the process size that is it cannot be larger than the size of the largest partition.

**4. Degree of multiprogramming is less**
By Degree of multi programming, we simply mean the maximum number of processes that can be loaded into the memory at the same time. In fixed partitioning, the degree of multiprogramming is fixed and very less due to the fact that the size of the partition cannot be varied according to the size of processes.

![[os-fixed-partitioning.png]]

#### 1.2 Variable Partitioning (Dynamic Partitioning)
Dynamic partitioning tries to overcome the problems caused by fixed partitioning. In this technique, **the partition size is not declared initially. It is declared at the time of process loading**.

The first partition is reserved for the operating system. The remaining space is divided into parts. **The size of each partition will be equal to the size of the process**. The partition size varies according to the need of the process so that the internal fragmentation can be avoided.

![[os-dynamic-partitioning.png]]


###### Advantages of Dynamic Partitioning over fixed partitioning

- **1. No Internal Fragmentation**
  Given the fact that the partitions in dynamic partitioning are created according to the need of the process, It is clear that there will not be any internal fragmentation because there will not be any unused remaining space in the partition.

- **2. No Limitation on the size of the process**
  In Fixed partitioning, the process with the size greater than the size of the largest partition could not be executed due to the lack of sufficient contiguous memory. Here, In Dynamic partitioning, the process size can't be restricted since the partition size is decided according to the process size.

- **3. Degree of multiprogramming is dynamic**
  The number of processes that can reside in the main memory at the same time is not fixed as it is in the Fixed Partitioning and can change based on system conditions, memory availability, and process requirements.


###### Disadvantages of dynamic partitioning

- **1.  External Fragmentation**
  Absence of internal fragmentation doesn't mean that there will not be external fragmentation.
  Let's consider three processes P1 (1 MB) and P2 (3 MB) and P3 (1 MB) are being loaded in the respective partitions of the main memory.
  After some time P1 and P3 got completed and their assigned space is freed. Now there are two unused partitions (1 MB and 1 MB) available in the main memory but they cannot be used to load a 2 MB process in the memory since they are not contiguously located.
  The rule says that the process must be contiguously present in the main memory to get executed. We need to change this rule to avoid external fragmentation.
  
![[os-dynamic-partitioning-external-fragmentation.png]]


- **2. Complex Memory Allocation**
  In Fixed partitioning, the list of partitions is made once and will never change but in dynamic partitioning, the allocation and deallocation is very complex since the partition size will be varied every time when it is assigned to a new process. OS has to keep track of all the partitions.
  Due to the fact that the allocation and deallocation are done very frequently in dynamic memory allocation and the partition size will be changed at each time, it is going to be very difficult for OS to manage everything.

##### Compaction
**Compaction is a memory management technique used to reduce or eliminate external fragmentation** in systems that use dynamic memory allocation. Over time, as processes are loaded and unloaded from memory, gaps (or free spaces) appear between allocated memory blocks, leading to external fragmentation. These gaps may collectively have enough free space for a new process, but because the memory is not contiguous, it cannot be used effectively.
This technique is also called defragmentation.

###### How Compaction Works:

1. **Shuffling Processes:** Compaction involves shifting the allocated memory blocks to one end of the memory space to create a large, contiguous block of free memory at the other end.
    
2. **Rearranging Free Spaces:** The scattered free spaces between processes are consolidated into one larger block of free memory, which can then be used for new processes or tasks.
    
3. **Process Relocation:** Since processes are moved during compaction, the memory addresses that the processes were using may change. The system needs to update these addresses in the process's tables to reflect the new memory locations.


![[os-compaction.png]]
As shown in the image above, the process P5, which could not be loaded into the memory due to the lack of contiguous space, can be loaded now in the memory since the free partitions are made contiguous.


###### Problem with Compaction

The efficiency of the system is decreased in the case of compaction due to the fact that all the free spaces will be transferred from several places to a single place.

Huge amount of time is invested for this procedure and the CPU will remain idle for all this time. Despite of the fact that the compaction avoids external fragmentation, it makes system inefficient.

Let us consider that OS needs 6 NS to copy 1 byte from one place to another.

```
 1 B transfer needs 6 NS   
 256 MB transfer needs 256 X 2^20 X 6 X 10 ^ -9 secs  
```

hence, it is proved to some extent that the larger size memory transfer needs some huge amount of time that is in seconds.


