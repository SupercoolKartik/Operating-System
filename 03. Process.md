**A process is a program in execution**. For example, **when we write a program** in C or C++ and compile it, **the compiler creates binary code**. The original code and binary code are both programs. **When we actually run the binary code, it becomes a process.** **A process is an ‘active’ entity** instead of **a program, which is considered a ‘passive’ entity.** 
A single program can create many processes when run multiple times; for example, when we open a .exe or binary file multiple times, multiple instances begin (multiple processes are created).

==PS:== When you start an application like Chrome, MS Word, the operating system creates a process for it. This process includes all the resources needed to run the application, such as memory, CPU time, and access to input/output devices.
- **Application:** A program.
- **Process:** When you open/run an application, it becomes a process. The operating system creates a process to manage the application's execution.

## Process Management
**Process management is a crucial function of an operating system that involves creating, scheduling, terminating, prioritizing processes and many more.**

The operating system **uses a number of methods to prevent deadlocks, facilitate inter-process communication, and synchronize processes.**

**Efficient resource allocation, conflict-free process execution, and optimal system performance are all guaranteed by competent process management.** This essential component of an operating system enables the execution of numerous applications at once, enhancing system utilization and responsiveness.


## How Does a Process Look Like in Memory?

![Alt Text](Process.png)
 
 - **Text Section:** Also known as the code segment, this section contains the executable [[Instructions]] of the program represented by the value of the [[Program Counter]]. This is where the actual code that the CPU executes is stored.
 - **Stack:** The stack is used for temporary storage during the execution of a process. It holds function parameters, [[Return Address | return addresses]], return values and local variables.
 - **Data Section:** Also known as the data segment, this section contains global and static variables that are initialized by the programmer.
 - **Heap:** The heap is used for dynamic memory allocation. Memory on the heap is allocated and deallocated as needed during the execution of the process using functions like `malloc`, `calloc`, `free` (in C), or `new`, `delete` (in C++).


## Characteristics of a Process

A process has the following attributes.

- **Process Id:** A unique identifier assigned by the operating system.
- **Process State:** Can be ready, running, etc.
- **CPU Registers:** Like the Program Counter (CPU registers must be saved and restored when a process is swapped in and out of the CPU)
- **Accounts Information:** Amount of CPU used for process execution, time limits, execution ID, etc.
- **I/O Status Information:** For example, devices allocated to the process, open files, etc
- **CPU Scheduling Information:** For example, Priority (Different processes may have different priorities, for example, a shorter process assigned high priority in the shortest job first scheduling)



## States of Process

A process is in one of the following states: 

- **New:** Newly Created Process (or) being-created process. (After the process is created from a program)
- **Ready:** After the creation process moves to the Ready state, i.e. the process is ready for execution (waiting for the CPU to become available).
- **Running:** Currently running process in CPU (only one process at a time can be under execution in a single processor).
- **Wait (or Block):** When a process requests I/O access.
- **Terminated (or Completed):** The process completed its execution.
- **Suspended Ready:** When the ready queue (the queue of processes that are ready to be executed by the CPU) becomes full, some processes are moved to a suspended ready state. A process in the suspended ready state can be moved back to the ready state when space becomes available in the ready queue.
- **Suspended Block:** When the waiting queue becomes full. When a process is in the waiting (or blocked) state and the waiting queue (the queue of processes waiting for I/O operations or other resources) becomes full, it is moved to a suspended block state. A process in the suspended block state can be moved back to the waiting state when space becomes available in the waiting queue.

![Alt Text](Process-Lifecycle.webp)

### Swapping
Swapping is a memory management technique used by operating systems to manage the limited physical memory available for processes. It involves moving processes between the main memory (RAM) and a secondary storage (usually a hard disk) to ensure that the CPU has a sufficient number of processes to execute, thereby optimizing resource utilization and system performance.

#### Swapping Process: 

1. **Swapping Out:**
    - The operating system selects a process that is either in the ready or blocked state.
    - The process's current state and memory contents are saved to secondary storage (swap space or disk).
    - The process state is changed to "suspended," and the process is moved to the suspended queue.

2. **Swapping In:**
    - When the operating system determines that the process needs to be brought back into memory (due to availability of memory or high priority), it is loaded back into RAM.
    - The process's state and memory contents are restored from secondary storage.
    - The process state is changed from "suspended" to "ready" or "blocked" based on its previous state.

**Process State Transition:**
- When a process is swapped out of memory, it transitions from the "ready" or "blocked" state to a "suspended ready" or "suspended blocked" state respectively.
- When a process is swapped back into memory, it transitions from the "suspended ready" or "suspended blocked" state back to the "ready" or "blocked" state respectively.

### Schedulers
Schedulers are crucial components of an operating system that **manage the execution of processes by determining the order in which processes run**. 

#### Types of Schedulers
There are three primary types of schedulers:

- **Long-Term Scheduler (Job Scheduler):** **Decides which jobs or processes should be made to stay in the ready state**. This decides the degree of multiprogramming (the number of processes in memory). Once a decision is taken **it lasts for a long time** which also indicates that it **runs infrequently**. Hence it is called a long-term scheduler.

- **Short-Term Scheduler (CPU Scheduler):** Short-term scheduler will **decide which process is to be executed next** and then it will call the [[dispatcher]]. A dispatcher is a software that moves the process from ready to run and vice versa. In other words, it is context switching. **It runs frequently** (milliseconds). Typically runs during every process switch.

- **Medium Scheduler:** Suspension decision is taken by the medium-term scheduler. The medium-term scheduler is used for [swapping](https://www.geeksforgeeks.org/swapping-in-operating-system/) which is moving the process from main memory to secondary and vice versa. The swapping is done to reduce degree of multiprogramming.


## Process Control Block (PCB)

**The Process Control Block (PCB) is a critical data structure used by the operating system to manage information about each process**. It acts as a **repository for all the data that is required to manage and track a process** during its lifecycle. Whenever the state of a process changes, the information in its PCB is updated accordingly.


![Alt Text](PCB.png)



### Components of the Process Control Block

1. **Pointer**: It's a stack pointer which is a register that points to the top of the current stack in memory. During a context switch, the current stack pointer value is saved in the PCB to retain the process's current execution state. When the process is rescheduled, this value is restored so the process can resume execution from the exact point it was interrupted.

2. **Process State**: Indicates the current state of the process i.e. New, Ready, Running, Waiting, Terminated. 

3. **Process Number** (Process ID or PID): A unique identifier assigned to each process. Used by the operating system to keep track of each process and manage process-specific resources and operations.

4. **Program Counter**: **Stores the address of the next instruction to be executed** for the process. Ensures that the process can resume execution from the correct instruction after being interrupted or switched out.
   - Instruction to be executed is fetched from the address in PC ---> PC++ (PC increments to the next instruction to be executed) ---> Execute the instruction which was fetched 
     ---> Cycle continues.

5. **Register**: CPU registers that hold process-specific data. **When a process's time slice expires, the current values of its registers are saved in the PCB**. **When the process is rescheduled, these values are restored to the CPU registers**, ensuring that the process continues execution correctly.
   - Time expires for a process ---> Values in the CPU register is stored in the PCB registers ---> CPU is freed for other processes ---> The process gets rescheduled ---> The register value from the PCB is restored to the CPU registers and process starts from where it was paused.  

6. **Memory Limits**: Information about the memory management system used by the operating system for the process. This may include page tables, segment tables, etc.

7. **List of Open files**: Information about the files currently opened by the process. Helps manage file I/O operations, ensuring that the process has access to the correct files and maintaining the status of these files.



## Orphan Process
An orphan process is **a process whose parent process has terminated but it is still running**, leaving it without a supervising parent.

**Handling Orphan Processes:**
In Unix-like systems, orphan processes are adopted by the `init` process (process ID 1), which ensures that they are properly managed and cleaned up after they finish execution. This mechanism helps maintain system stability and efficient resource utilization.

## Zombie Process
A zombie process (also known as a defunct process) is **a process that has completed execution but still has an entry in the process table**. This entry is retained to allow the parent process to read the child's exit status. A zombie process **does not consume any resources** like CPU or memory, **but it does occupy a slot in the process table**.

###### How Zombie Processes Occur:
- **Child Process Termination:**
    - When a child process terminates, it sends a `SIGCHLD` signal to its parent process.
- **Parent Process Inaction:**
    - If the parent process does not call `wait()` or `waitpid()` to read the exit status of the child process, the child process remains in the process table as a zombie. 
      ( When a child process terminates, the parent process must call `wait()` or `waitpid()` to read the child's exit status and remove the child's entry from the process table. This action prevents the child process from becoming a zombie, ensuring efficient resource management and system stability. These system calls are essential for handling process termination and maintaining a clean process environment.)




